<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Case2 : ScrollSpy - 출제자 해설</title>
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;700&display=swap"
      rel="stylesheet"
    />

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css"
    />
    <style>
      /*
      ==================== html => MD 작업 시, 꼭! 확인해주세요. ====================
      1. Markdown All in One : Print current document to HTML 실행. (VScode extension)
      2. 생성된 README.html에서 body 태그 안에 있는것들을 복사
      3. 루트 폴더에 README_OOO.md 생성 (OOO : Case 이름)
      4. ! 자동완성을 통해 기본 html 폼을 만들고, body태그 안에 <2>의 내용 붙여넣기
      5. font / code style에 관련된 <link>세줄과 <style> 태그 안에 있는 내용 붙여넣기
      6. 상단 <title> 태그 안에 <h2> 텍스트 삽입
      7. <img>태그 경로 변경해주기
      [ EXAMPLE ]
      [ 변경 전 ] : 절대경로로 되어있음
      <img
          width="600px"
          src="file:////Users/ming/Desktop/ui-component/case2_InfiniteScroll/example_image.gif"
        />
      [ 변경 후 ] : 상대경로로 수정
      <img
          width="600px"
          src="./example_image.gif"
        />
      8. html 내에 <h3>실행 방법 및 의존성 모듈 설치</h3> 하위 내용 아래와 같이 수정
      [ EXAMPLE ]
      [ 변경 전 ] : p에 className 없음
        <p>
          <strong>q1</strong>
          경로
          <code>./question/q1_js</code>
          index.html 열기
        </p>
      [ 변경 후 ] : p에 className 있음
        <p>
          <strong>q1</strong>
          경로
          <code>./question/q1_js</code>
          <p class="excute-text">index.html 열기</p>
        </p>


      [ 변경 전 ] : p태그와 pre태그가 div로 감싸져있지 않음
        <p>
          <strong>q4</strong>
          경로
          <code>./question/q4_react.js</code>
        </p>

        <p>터미널</p>
        <pre><code class="language-bash"><div>  $ npm install
        $ npm start
      </div></code></pre>

      [ 변경 후 ] : p태그와 pre태그가 div.code-wrap 으로 감싸져있음
        <p>
          <strong>q4</strong>
          경로
          <code>./question/q4_react.js</code>
        </p>
        
        <div class="code-wrap">
        <p>터미널</p>
        <pre>
          <code class="language-bash"><div>  $ npm install
      $ npm start
    </div></code></pre>
    </div>
    */
      html {
        overflow-x: hidden;
      }
      body {
        font-family: "Noto Sans KR", sans-serif;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      ul,
      ol,
      li,
      dl,
      dt,
      dd,
      p,
      table {
        margin: 0;
        padding: 0;
        color: #494949;
        letter-spacing: -0.025rem;
        box-sizing: border-box;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        font-weight: 600;
      }
      a {
        color: inherit;
        text-decoration: inherit;
      }

      a img {
        border: none;
      }

      img {
        max-width: 100%;
        vertical-align: middle;
      }

      ul li {
        list-style: none;
      }
      p {
        line-height: 1.8;
      }

      /* STYLE */
      body {
        padding: 0;
        margin: 0;
        line-height: 1.6;
      }
      h2 {
        padding: 50px 0;
        color: #ffffff;
        font-size: 2rem;
        text-align: center;
        background: linear-gradient(45deg, #ed234b, #ff6c89, #ff6fb7);
      }
      h2::before {
        content: "#";
        display: inline-block;
        margin-right: 5px;
        color: #ff9db0;
        font-weight: 300;
        font-size: 2.2rem;
      }
      h3 {
        position: relative;
        margin: 30px 20px;
        padding-bottom: 15px;
        color: #303030;
        font-size: 1.6rem;
        border-bottom: 1px solid #ededed;
      }

      blockquote {
        margin: 20px;
        padding: 20px;
        background: #f2f2f2;
      }

      strong {
        display: block;
        margin-top: 10px;
      }

      .code-wrap {
        position: relative;
        background: #2f303b;
        margin: 15px 0 0 0;
      }
      .code-wrap > p {
        position: absolute;
        left: 0;
        top: 0;
        padding: 2px 15px;
        font-size: 0.7rem;
        color: #ffffff;
        text-align: center;
        background: #61c8cc;
      }
      code {
        background: #ededed;
      }

      .language-css > div,
      .language-js > div {
        color: #fff;
        padding: 30px 20px;
        background: #2f303b;
      }
      code.language-bash div {
        margin-top: -20px;
        padding: 30px 20px;
        font-size: 1rem;
        color: #ffffff;
        background: #2f303b;
        box-sizing: border-box;
      }
      code::after {
        content: "";
        display: block;
      }
      code.inlineBlock::after {
        content: "";
        display: inline-block;
      }
      .excute-text {
        font-size: 0.8rem;
        font-weight: bold;
        color: #ed234b;
      }
      /* 좌, 우 여백 */
      ol,
      ul {
        margin: 20px;
        padding: 20px;
        background: #f2f2f2;
      }
      ol li {
        margin-left: 15px;
      }
      li {
        font-size: 0.85rem;
      }
      h4,
      h5,
      h6,
      p,
      img,
      pre {
        padding: 0 20px;
      }
    </style>
  </head>
  <body>
    <h2 id="case2--scrollspy---출제자-해설">Case2 : ScrollSpy - 출제자 해설</h2>
    <h3
      id="q1-문제-상황에-대하여-java-script로-동작을-구현시킬-수-있는-코드를-작성해보세요"
    >
      q1. 문제 상황에 대하여 Java Script로 동작을 구현시킬 수 있는 코드를
      작성해보세요
    </h3>
    <h4 id="a">A)</h4>
    <pre><code class="language-js"><div><span class="hljs-comment">// index.js</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./style.css&quot;</span>;

<span class="hljs-keyword">const</span> navElem = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#nav&quot;</span>);
<span class="hljs-keyword">const</span> navItems = <span class="hljs-built_in">Array</span>.from(navElem.children);
<span class="hljs-keyword">const</span> contentsElem = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#contents&quot;</span>);
<span class="hljs-keyword">const</span> contentItems = <span class="hljs-built_in">Array</span>.from(contentsElem.children);
<span class="hljs-keyword">const</span> offsetTops = contentItems.map(<span class="hljs-function">(<span class="hljs-params">elem</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> [ofs, clh] = [elem.offsetTop, elem.clientHeight];
  <span class="hljs-keyword">return</span> [ofs - clh / <span class="hljs-number">2</span>, ofs + clh / <span class="hljs-number">2</span>];
});

<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;scroll&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { scrollTop } = e.target.scrollingElement;
  <span class="hljs-comment">// do something</span>
  <span class="hljs-keyword">const</span> targetIndex = <span class="hljs-built_in">Math</span>.max(
    offsetTops.findIndex(<span class="hljs-function">(<span class="hljs-params">[<span class="hljs-keyword">from</span>, to]</span>) =&gt;</span> scrollTop &gt;= <span class="hljs-keyword">from</span> &amp;&amp; scrollTop &lt; to),
    <span class="hljs-number">0</span>
  );
  <span class="hljs-built_in">Array</span>.from(navElem.children).forEach(<span class="hljs-function">(<span class="hljs-params">c, i</span>) =&gt;</span> {
    c.classList[i === targetIndex ? <span class="hljs-string">&quot;add&quot;</span> : <span class="hljs-string">&quot;remove&quot;</span>](<span class="hljs-string">&quot;on&quot;</span>);
  });
});

navElem.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> targetElem = e.target;
  <span class="hljs-keyword">if</span> (targetElem.tagName === <span class="hljs-string">&quot;BUTTON&quot;</span>) {
    <span class="hljs-keyword">const</span> targetIndex = navItems.indexOf(targetElem.parentElement);
    contentItems[targetIndex].scrollIntoView({
      <span class="hljs-attr">block</span>: <span class="hljs-string">&quot;start&quot;</span>,
      <span class="hljs-attr">behavior</span>: <span class="hljs-string">&quot;smooth&quot;</span>,
    });
  }
});

</div></code></pre>
    <h5 id="해설">해설</h5>
    <ul>
      <li>
        offsetTop, scrollTop, clientHeight의 상관관계를 이해한다.
        scrollIntoView의 사용법을 익힌다.
      </li>
    </ul>
    <h3 id="q2-resize에-무관하게-동작하게끔-처리해보자">
      q2. resize에 무관하게 동작하게끔 처리해보자
    </h3>
    <h4 id="a-1">A)</h4>
    <pre><code class="language-js"><div><span class="hljs-comment">// index.js</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./style.css&quot;</span>;

<span class="hljs-keyword">const</span> navElem = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#nav&quot;</span>);
<span class="hljs-keyword">const</span> navItems = <span class="hljs-built_in">Array</span>.from(navElem.children);
<span class="hljs-keyword">const</span> contentsElem = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#contents&quot;</span>);
<span class="hljs-keyword">const</span> contentItems = <span class="hljs-built_in">Array</span>.from(contentsElem.children);
<span class="hljs-keyword">const</span> getOffsetTops = (<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">let</span> offsetTops = [];
  <span class="hljs-keyword">let</span> prevHeight = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.innerHeight === prevHeight) {
      <span class="hljs-keyword">return</span> offsetTops;
    }
    offsetTops = contentItems.map(<span class="hljs-function"><span class="hljs-params">elem</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> [ofs, clh] = [elem.offsetTop, elem.clientHeight];
      <span class="hljs-keyword">return</span> [ofs - clh / <span class="hljs-number">2</span>, ofs + clh / <span class="hljs-number">2</span>];
    });
    prevHeight = <span class="hljs-built_in">window</span>.innerHeight;
    <span class="hljs-keyword">return</span> offsetTops;
  };
})();

<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;scroll&quot;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> { scrollTop } = e.target.scrollingElement;
  <span class="hljs-keyword">const</span> targetIndex = <span class="hljs-built_in">Math</span>.max(
    getOffsetTops().findIndex(
      <span class="hljs-function">(<span class="hljs-params">[<span class="hljs-keyword">from</span>, to]</span>) =&gt;</span> scrollTop &gt;= <span class="hljs-keyword">from</span> &amp;&amp; scrollTop &lt; to
    ),
    <span class="hljs-number">0</span>
  );
  <span class="hljs-built_in">Array</span>.from(navElem.children).forEach(<span class="hljs-function">(<span class="hljs-params">c, i</span>) =&gt;</span> {
    i === targetIndex ? c.classList.add(<span class="hljs-string">&quot;on&quot;</span>) : c.classList.remove(<span class="hljs-string">&quot;on&quot;</span>);
  });
});

navElem.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> targetElem = e.target;
  <span class="hljs-keyword">if</span> (targetElem.tagName === <span class="hljs-string">&quot;BUTTON&quot;</span>) {
    <span class="hljs-keyword">const</span> targetIndex = navItems.indexOf(targetElem.parentElement);
    contentItems[targetIndex].scrollIntoView({
      <span class="hljs-attr">block</span>: <span class="hljs-string">&quot;start&quot;</span>,
      <span class="hljs-attr">behavior</span>: <span class="hljs-string">&quot;smooth&quot;</span>,
    });
  }
});


</div></code></pre>
    <h5 id="해설-1">해설</h5>
    <ul>
      <li>화면 높이가 바뀌면 변경내용을 반영할 필요가 있다.</li>
    </ul>
    <h3 id="q3-resize-listener를-적용해서-구현해보자">
      q3. resize listener를 적용해서 구현해보자.
    </h3>
    <h4 id="a-2">A)</h4>
    <pre><code class="language-js"><div><span class="hljs-comment">// index.js</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./style.css&quot;</span>;

<span class="hljs-keyword">const</span> navElem = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#nav&quot;</span>);
<span class="hljs-keyword">const</span> navItems = <span class="hljs-built_in">Array</span>.from(navElem.children);
<span class="hljs-keyword">const</span> contentsElem = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#contents&quot;</span>);
<span class="hljs-keyword">const</span> contentItems = <span class="hljs-built_in">Array</span>.from(contentsElem.children);

<span class="hljs-keyword">let</span> offsetTops = [];
<span class="hljs-keyword">const</span> getOffsetTops = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// do something</span>
  offsetTops = contentItems.map(<span class="hljs-function"><span class="hljs-params">elem</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> [ofs, clh] = [elem.offsetTop, elem.clientHeight];
    <span class="hljs-keyword">return</span> [ofs - clh / <span class="hljs-number">2</span>, ofs + clh / <span class="hljs-number">2</span>];
  });
};
getOffsetTops();

<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;scroll&quot;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> { scrollTop } = e.target.scrollingElement;
  <span class="hljs-keyword">const</span> targetIndex = <span class="hljs-built_in">Math</span>.max(
    offsetTops.findIndex(<span class="hljs-function">(<span class="hljs-params">[<span class="hljs-keyword">from</span>, to]</span>) =&gt;</span> scrollTop &gt;= <span class="hljs-keyword">from</span> &amp;&amp; scrollTop &lt; to),
    <span class="hljs-number">0</span>
  );
  <span class="hljs-built_in">Array</span>.from(navElem.children).forEach(<span class="hljs-function">(<span class="hljs-params">c, i</span>) =&gt;</span> {
    i === targetIndex ? c.classList.add(<span class="hljs-string">&quot;on&quot;</span>) : c.classList.remove(<span class="hljs-string">&quot;on&quot;</span>);
  });
});

<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;resize&quot;</span>, getOffsetTops);

navElem.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> targetElem = e.target;
  <span class="hljs-keyword">if</span> (targetElem.tagName === <span class="hljs-string">&quot;BUTTON&quot;</span>) {
    <span class="hljs-keyword">const</span> targetIndex = navItems.indexOf(targetElem.parentElement);
    contentItems[targetIndex].scrollIntoView({
      <span class="hljs-attr">block</span>: <span class="hljs-string">&quot;start&quot;</span>,
      <span class="hljs-attr">behavior</span>: <span class="hljs-string">&quot;smooth&quot;</span>
    });
  }
});

</div></code></pre>
    <h5 id="해설-2">해설</h5>
    <ul>
      <li>
        2의 함수는 리사이즈가 있을 때엔 의미가 있으나, 그렇지 않은 경우에도
        스크롤할 때마다 함수가 실행되면서 각 엘리먼트의 높이를 구하게 된다.
        이보다는 리사이즈시에만 계산을 하고, 평소에는 미리 계산된 값을
        이용하는게 효율적일 것이다.
      </li>
    </ul>
    <h3 id="q4-throttle로-처리">q4. throttle로 처리</h3>
    <h4 id="a-3">A)</h4>
    <pre><code class="language-js"><div><span class="hljs-comment">//util.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> debounce = <span class="hljs-function">(<span class="hljs-params">func, delay</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> timeoutId = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...arg</span>) =&gt;</span> {
    <span class="hljs-built_in">clearTimeout</span>(timeoutId);
    timeoutId = <span class="hljs-built_in">setTimeout</span>(func.bind(<span class="hljs-literal">null</span>, ...arg), delay);
  };
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> throttle = <span class="hljs-function">(<span class="hljs-params">func, ms</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> throttled = <span class="hljs-literal">false</span>;
  <span class="hljs-comment">// do something</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (!throttled) {
      throttled = <span class="hljs-literal">true</span>;
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        func(...args);
        throttled = <span class="hljs-literal">false</span>;
      }, ms);
    }
  };
};

</div></code></pre>
    <h5 id="해설-3">해설</h5>
    <ul>
      <li>
        스크롤 이벤트는 스크롤 동작을 하는 동안 계속해서 발생하므로 모든
        이벤트에 대해 콜백을 호출하는 것은 성능에 좋지 않다. 마지막 이벤트만을
        감시하는 것으로 충분했던 무한스크롤과 달리 연속적인 이벤트에 대해 꾸준히
        변경사항을 반영하는 것이 필요하므로, throttle이 적합하다.
      </li>
    </ul>
    <h3 id="q5-intersection-observer-활용">q5. intersection Observer 활용</h3>
    <h4 id="a-4">A)</h4>
    <pre><code class="language-js"><div><span class="hljs-comment">//index.js</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./style.css&quot;</span>;

<span class="hljs-keyword">const</span> navElem = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#nav&quot;</span>);
<span class="hljs-keyword">const</span> navItems = <span class="hljs-built_in">Array</span>.from(navElem.children);
<span class="hljs-keyword">const</span> contentsElem = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#contents&quot;</span>);
<span class="hljs-keyword">const</span> contentItems = <span class="hljs-built_in">Array</span>.from(contentsElem.children);

<span class="hljs-keyword">const</span> scrollSpyObserver = <span class="hljs-keyword">new</span> IntersectionObserver(
  <span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {
    <span class="hljs-comment">// do something</span>
    <span class="hljs-keyword">const</span> { target } = entries.find(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> entry.isIntersecting) || {};
    <span class="hljs-keyword">const</span> targetIndex = contentItems.indexOf(target);
    <span class="hljs-built_in">Array</span>.from(navElem.children).forEach(<span class="hljs-function">(<span class="hljs-params">c, i</span>) =&gt;</span> {
      c.classList[i === targetIndex ? <span class="hljs-string">&quot;add&quot;</span> : <span class="hljs-string">&quot;remove&quot;</span>](<span class="hljs-string">&quot;on&quot;</span>);
    });
  },
  {
    <span class="hljs-attr">root</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">&quot;0px&quot;</span>,
    <span class="hljs-attr">threshold</span>: <span class="hljs-number">0.5</span>,
  }
);
contentItems.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> scrollSpyObserver.observe(item));

navElem.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> targetElem = e.target;
  <span class="hljs-keyword">if</span> (targetElem.tagName === <span class="hljs-string">&quot;BUTTON&quot;</span>) {
    <span class="hljs-keyword">const</span> targetIndex = navItems.indexOf(targetElem.parentElement);
    contentItems[targetIndex].scrollIntoView({
      <span class="hljs-attr">block</span>: <span class="hljs-string">&quot;start&quot;</span>,
      <span class="hljs-attr">behavior</span>: <span class="hljs-string">&quot;smooth&quot;</span>,
    });
  }
});

</div></code></pre>
    <h3 id="q6-react--intersection-observer-활용">
      q6. React + intersection Observer 활용
    </h3>
    <h4 id="a-5">A)</h4>
    <pre><code class="language-js"><div><span class="hljs-comment">//App.js</span>

<span class="hljs-keyword">import</span> React, { useState, useRef, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> Nav <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Nav&quot;</span>;
<span class="hljs-keyword">import</span> Content <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Content&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./style.css&quot;</span>;

<span class="hljs-keyword">const</span> pages = <span class="hljs-built_in">Array</span>.from({ <span class="hljs-attr">length</span>: <span class="hljs-number">8</span> }).map(<span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> i + <span class="hljs-number">1</span>);

<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> [viewIndex, setViewIndex] = useState(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> contentRef = useRef([]);
  <span class="hljs-keyword">const</span> moveToPage = <span class="hljs-function">(<span class="hljs-params">index</span>) =&gt;</span> <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// do something</span>
    contentRef.current[index].scrollIntoView({
      <span class="hljs-attr">block</span>: <span class="hljs-string">&quot;start&quot;</span>,
      <span class="hljs-attr">behavior</span>: <span class="hljs-string">&quot;smooth&quot;</span>,
    });
  };

  <span class="hljs-keyword">const</span> scrollSpyObserver = <span class="hljs-keyword">new</span> IntersectionObserver(
    <span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {
      <span class="hljs-comment">// do something</span>
      <span class="hljs-keyword">const</span> { target } = entries.find(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> entry.isIntersecting) || {};
      setViewIndex(contentRef.current.indexOf(target));
    },
    {
      <span class="hljs-attr">root</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">&quot;0px&quot;</span>,
      <span class="hljs-attr">threshold</span>: <span class="hljs-number">0.5</span>,
    }
  );

  useEffect(<span class="hljs-function">() =&gt;</span> {
    contentRef.current.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> scrollSpyObserver.observe(item));
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      contentRef.current.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> scrollSpyObserver.unobserve(item));
    };
  }, []);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Nav</span> <span class="hljs-attr">pages</span>=<span class="hljs-string">{pages}</span> <span class="hljs-attr">viewIndex</span>=<span class="hljs-string">{viewIndex}</span> <span class="hljs-attr">moveToPage</span>=<span class="hljs-string">{moveToPage}</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;contents&quot;</span>&gt;</span>
        {pages.map((p, i) =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{p}</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{(r)</span> =&gt;</span> (contentRef.current[i] = r)} page={p} /&gt;
        ))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App

</div></code></pre>
  </body>
</html>
