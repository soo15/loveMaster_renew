<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Case1 : ContextMenu - 대기업 S사 프론트엔드 개발자님의 답안</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" />
  <link
    href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;700&display=swap"
    rel="stylesheet"
  />

  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css"
  />
  <style>
    /*
      ==================== html => MD 작업 시, 꼭! 확인해주세요. ====================
      1. Markdown All in One : Print current document to HTML 실행. (VScode extension)
      2. 생성된 README.html에서 body 태그 안에 있는것들을 복사
      3. 루트 폴더에 README_OOO.md 생성 (OOO : Case 이름)
      4. ! 자동완성을 통해 기본 html 폼을 만들고, body태그 안에 <2>의 내용 붙여넣기
      5. font / code style에 관련된 <link>세줄과 <style> 태그 안에 있는 내용 붙여넣기
      6. 상단 <title> 태그 안에 <h2> 텍스트 삽입
      7. <img>태그 경로 변경해주기
      [ EXAMPLE ]
      [ 변경 전 ] : 절대경로로 되어있음
      <img
          width="600px"
          src="file:////Users/ming/Desktop/ui-component/case2_InfiniteScroll/example_image.gif"
        />
      [ 변경 후 ] : 상대경로로 수정
      <img
          width="600px"
          src="./example_image.gif"
        />
      8. html 내에 <h3>실행 방법 및 의존성 모듈 설치</h3> 하위 내용 아래와 같이 수정
      [ EXAMPLE ]
      [ 변경 전 ] : p에 className 없음
        <p>
          <strong>q1</strong>
          경로
          <code>./question/q1_js</code>
          index.html 열기
        </p>
      [ 변경 후 ] : p에 className 있음
        <p>
          <strong>q1</strong>
          경로
          <code>./question/q1_js</code>
          <p class="excute-text">index.html 열기</p>
        </p>


      [ 변경 전 ] : p태그와 pre태그가 div로 감싸져있지 않음
        <p>
          <strong>q4</strong>
          경로
          <code>./question/q4_react.js</code>
        </p>

        <p>터미널</p>
        <pre><code class="language-bash"><div>  $ npm install
        $ npm start
      </div></code></pre>

      [ 변경 후 ] : p태그와 pre태그가 div.code-wrap 으로 감싸져있음
        <p>
          <strong>q4</strong>
          경로
          <code>./question/q4_react.js</code>
        </p>
        
        <div class="code-wrap">
        <p>터미널</p>
        <pre>
          <code class="language-bash"><div>  $ npm install
      $ npm start
    </div></code></pre>
    </div>
    */
    html {
      overflow-x: hidden;
    }
    body {
      font-family: "Noto Sans KR", sans-serif;
    }
    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    ul,
    ol,
    li,
    dl,
    dt,
    dd,
    p,
    table {
      margin: 0;
      padding: 0;
      color: #494949;
      letter-spacing: -0.025rem;
      box-sizing: border-box;
    }
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      font-weight: 600;
    }
    a {
      color: inherit;
      text-decoration: inherit;
    }

    a img {
      border: none;
    }

    img {
      max-width: 100%;
      vertical-align: middle;
    }

    ul li {
      list-style: none;
    }
    p {
      line-height: 1.8;
    }

    /* STYLE */
    body {
      padding: 0;
      margin: 0;
      line-height: 1.6;
    }
    h2 {
      padding: 50px 0;
      color: #ffffff;
      font-size: 2rem;
      text-align: center;
      background: linear-gradient(45deg, #ed234b, #ff6c89, #ff6fb7);
    }
    h2::before {
      content: "#";
      display: inline-block;
      margin-right: 5px;
      color: #ff9db0;
      font-weight: 300;
      font-size: 2.2rem;
    }
    h3 {
      position: relative;
      margin: 30px 20px;
      padding-bottom: 15px;
      color: #303030;
      font-size: 1.6rem;
      border-bottom: 1px solid #ededed;
    }

    blockquote {
      margin: 20px;
      padding: 20px;
      background: #f2f2f2;
    }

    strong {
      display: block;
      margin-top: 10px;
    }

    .code-wrap {
      position: relative;
      background: #2f303b;
      margin: 15px 0 0 0;
    }
    .code-wrap > p {
      position: absolute;
      left: 0;
      top: 0;
      padding: 2px 15px;
      font-size: 0.7rem;
      color: #ffffff;
      text-align: center;
      background: #61c8cc;
    }
    code {
      background: #ededed;
    }

    .language-css > div,
    .language-js > div {
      color: #fff;
      padding: 30px 20px;
      background: #2f303b;
    }
    code.language-bash div {
      margin-top: -20px;
      padding: 30px 20px;
      font-size: 1rem;
      color: #ffffff;
      background: #2f303b;
      box-sizing: border-box;
    }
    code::after {
      content: "";
      display: block;
    }

    .excute-text {
      font-size: 0.8rem;
      font-weight: bold;
      color: #ed234b;
    }
    /* 좌, 우 여백 */
    ol,
    ul {
      margin: 20px;
      padding: 20px;
      background: #f2f2f2;
    }
    ol li {
      margin-left: 15px;
    }
    li {
      font-size: 0.85rem;
    }
    h4,
    h5,
    h6,
    p,
    img,
    pre {
      padding: 0 20px;
    }
  </style>
</head>
<body>
  <h2 id="case1--contextmenu---대기업-s사-프론트엔드-개발자님의-답안">Case1 : ContextMenu - 대기업 S사 프론트엔드 개발자님의 답안</h2>
<h3 id="q1-문제-상황에-대하여-java-script로-동작을-구현시킬-수-있는-코드를-작성해보세요">q1. 문제 상황에 대하여 Java Script로 동작을 구현시킬 수 있는 코드를 작성해보세요</h3>
<pre><code class="language-js"><div><span class="hljs-comment">/**
 * 각 아이템 항목의 클릭 이벤트를 위임받을 컨테이너
 */</span>
<span class="hljs-keyword">const</span> containerEl = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.container&quot;</span>);

<span class="hljs-comment">/**
 * 가장 마지막으로 선택된 엘리먼트를 저장
 */</span>
<span class="hljs-keyword">let</span> latestOpnedEl = <span class="hljs-literal">null</span>;

<span class="hljs-comment">/**
 * 클릭 이벤트가 `Document` 까지 전파된 경우 마지막에 열린 창을 닫음
 */</span>
<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (latestOpnedEl) {
    latestOpnedEl?.classList.remove(<span class="hljs-string">&quot;open&quot;</span>);
    latestOpnedEl = <span class="hljs-literal">null</span>;
  }
});

<span class="hljs-comment">/**
 * 컨테이너에 클릭 이벤트를 바인딩
 */</span>
containerEl.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
  <span class="hljs-comment">/**
   * 이벤트가 상위(`Document`) 객체로 전달되지 않도록 `stopPropagation` 호출
   * @see https://developer.mozilla.org/ko/docs/Web/API/Event/stopPropagation
   */</span>
  e.stopPropagation();
  <span class="hljs-keyword">const</span> targetEl = e.target;

  <span class="hljs-comment">/**
   * 가장 마지막에 선택된 엘리먼트의 `open` 클래스를 제거
   */</span>
  latestOpnedEl?.classList.remove(<span class="hljs-string">&quot;open&quot;</span>);

  <span class="hljs-comment">/**
   * 현재 선택된 엘리먼트와 마지막에 선택된 엘리먼트가 동일하다면 아무것도 하지 않음
   */</span>
  <span class="hljs-keyword">if</span> (latestOpnedEl === targetEl) {
    latestOpnedEl = targetEl;
    <span class="hljs-keyword">return</span>;
  }

  targetEl?.classList.add(<span class="hljs-string">&quot;open&quot;</span>);
  latestOpnedEl = targetEl;
});
</div></code></pre>
<h5 id="해설">해설</h5>
<ol>
<li>이벤트를 위임받기 적당한 컨테이너 셀렉터를 입력</li>
</ol>
<ul>
<li>아이템의 상위 요소라면 어떤걸 선택해도 문제되지는 않지만 가급적 가장 인접한 <code>container</code> 항목을 선택하는것이 좋음
(최상위 엘리먼트에 모든 이벤트가 집중된 경우, 매 이벤트 동작마다 등록된 모든 이벤트를 탐색해야하는 불필요한 연산이 발생하게되고, 더이상 사용되지 않는 자식요소 DOM 엘리먼트 제거시 바인딩된 이벤트를 직접 제거해 주지 않는경우에도 불필요한 연산이 발생)</li>
</ul>
<ol start="2">
<li>이벤트 객체에서 이벤트가 발생된 엘리먼트 객체를 선택해 주세요.</li>
</ol>
<ul>
<li>
<p><code>e.target</code>, <code>e.currentTarget</code> 두 값의 의미를 제대로 구분할 수 있어야함</p>
<ul>
<li>[참고] <a href="https://developer.mozilla.org/ko/docs/Web/API/Event/target">https://developer.mozilla.org/ko/docs/Web/API/Event/target</a></li>
<li>[참고] <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget">https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget</a></li>
</ul>
</li>
<li>
<p><strong>각각의 항목에 이벤트를 바인딩 하지 않고 컨테이너에서 이벤트를 위임(Event Delegation)받아 처리함으로써 이벤트 처리 성능 향상</strong></p>
<blockquote>
<p>항목별 이벤트를 직접 등록하는 경우 이벤트 리스너를 등록하는 시간과 메모리 리소스 사용이 증가합니다. 항목이 적거나 성능이 좋은 최신 브라우저에서는 차이를 느끼기 쉽지 않지만, IE8 이하 버전과 같은
구형 브라우저 버전에서는 항목이 늘어나면 성능 차이가 눈에 보일 정도로 느껴질 수 있습니다.</p>
</blockquote>
<ul>
<li><code>containerEl</code> 하위요소에서 발생하는 <em>click</em> 이벤트는 버블링되어 <code>containerEl</code>으로 전파되어 <code>containerEl</code>에 등록된 클릭 이벤트 리스너에서 처리됨</li>
<li>[참고] <a href="https://developer.mozilla.org/ko/docs/Web/API/Event/eventPhase">https://developer.mozilla.org/ko/docs/Web/API/Event/eventPhase</a></li>
<li>[참고] <a href="https://developer.mozilla.org/ko/docs/Web/API/EventTarget/addEventListener">https://developer.mozilla.org/ko/docs/Web/API/EventTarget/addEventListener</a></li>
</ul>
</li>
<li>
<p><strong>DOM 탐색 시간을 줄이기 위해 <code>latestOpnedEl</code> 변수에 가장 마지막으로 열린 <em>HTMLElement</em> 항목을 저장</strong></p>
<ul>
<li>매 번 <em>DOM</em> 을 순회하며 <em>Attribute</em> 에 저장된 상태를 확인하여 열려있는 <em>HTMLEement</em> 를 확인하는 방법도 있지만, 불필요한 연산을 줄여 성능을 조금더 빠르게 하기 위해 가장 마지막에 열린 <em>HTMLElement</em> 를 <code>latestOpnedEl</code> 변수에 저장하도록 구현 하였습니다.</li>
</ul>
</li>
<li>
<p><strong><code>latestOpnedEl</code> 상태를 사용하는 이유</strong></p>
<blockquote>
<p>[!] 위와 같이 성능을 더 높히는 대신 <code>latestOpnedEl</code> 변수의 상태를 관리해야하는 약간의 번거로움(?)이 있습니다. 이 부분에 대해서는 어플리케이션의 성능이나 복잡도를 고려하여 개발상황에 맞게 참고하면
좋을것 같습니다.</p>
</blockquote>
<ul>
<li>이벤트 위임을 사용함으로써 자동으로 이벤트 리스너를 등록되어 관리가 필요 없는 이점도 있지만, 가능하다면 성능적인 부분은 작은곳부터 관리하는게 좋습니다. 가령 항목의 갯수가 100개 이상이라고 가정 했을때
항목을 클릭할때마다 100개의 리스트에서 열려있는 상태의 <em>HTMLElement</em> 찾아야 합니다.</li>
</ul>
</li>
</ul>
<h3 id="q2-문제-상황에-대하여-jquery로-동작을-구현시킬-수-있는-코드를-작성해보세요">q2. 문제 상황에 대하여 jquery로 동작을 구현시킬 수 있는 코드를 작성해보세요</h3>
<pre><code class="language-js"><div><span class="hljs-comment">// Write JQuery code here!</span>
<span class="hljs-comment">/**
 * 각 아이템 항목의 클릭 이벤트를 위임받을 컨테이너
 */</span>
<span class="hljs-keyword">const</span> $container = $(<span class="hljs-string">&quot;.container&quot;</span>);

<span class="hljs-comment">/**
 * 가장 마지막으로 선택된 엘리먼트를 저장
 */</span>
<span class="hljs-keyword">let</span> $latestOpned = <span class="hljs-literal">null</span>;

$(<span class="hljs-built_in">document</span>).on(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">if</span> ($latestOpned) {
    $latestOpned.removeClass(<span class="hljs-string">&quot;open&quot;</span>);
    $latestOpned = <span class="hljs-literal">null</span>;
  }
});

<span class="hljs-comment">/**
 * Jquery `on` 함수를 이용하여 이벤트 위임하여 바인딩
 */</span>
$container.on(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-string">&quot;.item&quot;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
  e.stopPropagation();

  <span class="hljs-comment">// ⇛ 1) Jquery 라이브러리의 on 함수를 이용하여 이벤트 위임을 이용하여 이벤트를 추가해 주세요</span>
  <span class="hljs-keyword">const</span> $target = $(e.target);
  <span class="hljs-comment">/**
   * 가장 마지막에 선택된 엘리먼트의 `open` 클래스를 제거
   */</span>
  $latestOpned?.removeClass(<span class="hljs-string">&quot;open&quot;</span>);

  <span class="hljs-comment">/**
   * 현재 선택된 엘리먼트와 마지막에 선택된 엘리먼트가 동일하다면 아무것도 하지 않음
   */</span>
  <span class="hljs-keyword">if</span> ($latestOpned?.get(<span class="hljs-number">0</span>) === $target?.get(<span class="hljs-number">0</span>)) {
    $latestOpned = $target;
    <span class="hljs-keyword">return</span>;
  }

  $target.addClass(<span class="hljs-string">&quot;open&quot;</span>);
  $latestOpned = $target;
});
</div></code></pre>
<h5 id="해설-1">해설</h5>
<ol>
<li>
<p><a href="https://jquery.com/"><em>Jquery</em></a> 라이브러리의 <code>on</code> 함수를 이용하여 이벤트 위임을 이용하여 이벤트를 추가</p>
<ul>
<li><em>Jquery</em> 에서는 이벤트 위임이 이미 구현되어 있음</li>
<li>[참고] <a href="https://api.jquery.com/on/">https://api.jquery.com/on/</a></li>
</ul>
</li>
<li>
<p>클릭 이벤트가 상위로 전파되지 않도록 함수를 호출</p>
<ul>
<li>[참고] <a href="https://developer.mozilla.org/ko/docs/Web/API/Event/stopPropagation">https://developer.mozilla.org/ko/docs/Web/API/Event/stopPropagation</a></li>
</ul>
</li>
</ol>
<ul>
<li><strong>기본적인 구현원리는 <a href="#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4-%EC%84%A4%EB%AA%85-explanation1">Javascript 문제풀이</a>와 동일합니다.</strong></li>
<li><strong>이벤트 위임 구현 로직을 <em>Jquery</em> 이벤트 바인딩 함수(<code>on</code>)에서 제공하는 기능으로 대체</strong>
<ul>
<li><em>Jquery</em> 라이브러리에서 제공하는 이벤트 바인딩 함수(<code>on</code>)의 두번째 인자에 <em>Selector</em> 를 지정하는 경우 이벤트 위임을 사용하실 수 있습니다.</li>
<li>[참고] <a href="https://api.jquery.com/on/">https://api.jquery.com/on/</a></li>
</ul>
</li>
</ul>
<h3 id="q3-문제-상황에-대하여-jquery로-동작을-구현시킬-수-있는-코드를-작성해보세요">q3. 문제 상황에 대하여 jquery로 동작을 구현시킬 수 있는 코드를 작성해보세요</h3>
<pre><code class="language-js"><div><span class="hljs-comment">/**
 * 각 아이템 항목의 클릭 이벤트를 위임받을 컨테이너
 */</span>
<span class="hljs-keyword">const</span> containerEl = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.container&quot;</span>);
<span class="hljs-comment">/**
 * 가장 마지막으로 선택된 엘리먼트를 저장
 */</span>
<span class="hljs-keyword">let</span> latestOpendEl = <span class="hljs-literal">null</span>;

<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> {
  latestOpendEl?.removeAttribute(<span class="hljs-string">&quot;open&quot;</span>);
  latestOpendEl = <span class="hljs-literal">null</span>;
});

containerEl.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
  <span class="hljs-keyword">let</span> detailsEl = e.target;
  <span class="hljs-comment">/**
   * 가장 마지막에 선택된 `details` 엘리먼트의 `open` 속성을 제거
   */</span>
  latestOpendEl?.removeAttribute(<span class="hljs-string">&quot;open&quot;</span>);
  <span class="hljs-comment">/**
   * 현재 클릭된 엘리먼트로 부터 부모 엘리먼트를 확인하여 `details` 엘리먼트를 찾음
   * 루트 엘리먼트에 도달한 경우 `target.parentElement` 값은 `null`
   */</span>
  <span class="hljs-keyword">do</span> {
    <span class="hljs-comment">/**
     * 현재 클릭된 엘리먼트의 부모 엘리먼트가 `details`인 경우
     */</span>
    <span class="hljs-keyword">if</span> (detailsEl?.tagName === <span class="hljs-string">&quot;DETAILS&quot;</span>) {
      <span class="hljs-comment">/**
       * 태그의 기본동작을(이벤트) 막아 `open` 속성이 자동으로 추가되지 않도록 함
       */</span>
      e.stopPropagation();
      e.preventDefault();

      <span class="hljs-keyword">if</span> (detailsEl === latestOpendEl) {
        <span class="hljs-comment">/**
         * 현재 선택된 `details` 엘리먼트가 마지막 선택된 `details`와 동일한 경우 아무것도 하지 않음
         */</span>
        latestOpendEl = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">break</span>;
      }

      <span class="hljs-comment">/**
       * `open` 속성을 수동으로 추가
       */</span>
      detailsEl.setAttribute(<span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);
      latestOpendEl = detailsEl;
      <span class="hljs-keyword">break</span>;
    }
  } <span class="hljs-keyword">while</span> ((detailsEl = detailsEl?.parentElement) !== <span class="hljs-literal">null</span>);
});
</div></code></pre>
<h5 id="해설-2">해설</h5>
<ol>
<li>기본 이벤트(태그 동작)이 실행되지 않도록 특정 함수를 호출
<ul>
<li>이벤트 위임 구현 원리, 이벤트 취소(<code>preventDefault</code>)에 대한 이해가 필요한 내용으로 보여짐</li>
<li>[참고] <a href="https://developer.mozilla.org/ko/docs/Web/API/Event/preventDefault">https://developer.mozilla.org/ko/docs/Web/API/Event/preventDefault</a></li>
</ul>
</li>
</ol>
<ul>
<li>
<p><strong>기본적인 구현원리는 <a href="#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4-%EC%84%A4%EB%AA%85-explanation1">Javascript 문제풀이</a>와 동일합니다.</strong></p>
</li>
<li>
<p><strong>이벤트 발생시 현재 타겟(클릭된)으로부터 <code>details</code> 태그를 탐색하는 코드가 추가.</strong></p>
<ul>
<li><code>details</code> 태그 하위에는 다른 태그 속성들이 중첩되어 포함될 수 있기 때문에, 클릭된 태그(<code>HTMLElement</code>)로 부터 한단계씩 상위 태그를 확인하며 <code>details</code> 태그가 나타날때 까지 탐색하고 결과를 저장합니다.</li>
</ul>
</li>
<li>
<p><strong><code>toggle</code> 이벤트 대신 <code>click</code> 이벤트를 사용하는 이유</strong></p>
<ul>
<li><code>details</code> 태그는 <code>toggle</code> 이벤트를 지원하지만, 컨테이너 태그인 <code>div</code>에서는 <code>toggle</code> 이벤트를 리스닝 할 수 없기 때문에, 컨테이너 <code>div</code>에서는 <code>click</code> 이벤트를 활용하여 <code>toggle</code> 이벤트가 발생하기 전
<code>e.preventDefault()</code> 를 이용하여 <em>toggle</em> 동작을 실행되지 않도록하고 <code>open</code> 속성을 직접 추가하도록 구현 하였습니다.</li>
<li>[참고] <a href="https://developer.mozilla.org/ko/docs/Web/HTML/Element/details">https://developer.mozilla.org/ko/docs/Web/HTML/Element/details</a></li>
</ul>
</li>
</ul>
<h3 id="q4-문제-상황에-대하여-react로-동작을-구현시킬-수-있는-코드를-작성해보세요">q4. 문제 상황에 대하여 React로 동작을 구현시킬 수 있는 코드를 작성해보세요</h3>
<pre><code class="language-js"><div><span class="hljs-keyword">import</span> React, { useState, useRef, useLayoutEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./style.css&quot;</span>;
<span class="hljs-keyword">import</span> Detail <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Detail&quot;</span>;
<span class="hljs-keyword">import</span> dummyData <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./dummyData&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">/**
   * 가장 최근에 열린 `defail` 저장
   */</span>
  <span class="hljs-keyword">const</span> latestOpenedItemElRef = useRef(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">/**
   * 가장 최근에 열린 `defail` 닫음
   */</span>
  <span class="hljs-keyword">const</span> closeLatestOpenedItem = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (latestOpenedItemElRef.current) {
      latestOpenedItemElRef.current.removeAttribute(<span class="hljs-string">&quot;open&quot;</span>);
    }
  };

  useLayoutEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">/**
     * `document`에 클릭 이벤트 발생시 가장 최근에 열린 `detail`을 닫음
     */</span>
    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, closeLatestOpenedItem);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">&quot;click&quot;</span>, closeLatestOpenedItem);
    };
  }, []);

  <span class="hljs-keyword">const</span> handleClickDetail = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-comment">/**
     * `toggle` 이벤트가 발생하지 않도록 기본 이벤트 동작 취소
     */</span>
    e.preventDefault();
    <span class="hljs-comment">/**
     * `click` 이벤트가 `document` 까지 전파되지 않도록 방지
     */</span>
    e.stopPropagation();
    <span class="hljs-keyword">const</span> currentTarget = e.currentTarget;
    <span class="hljs-keyword">const</span> latestOpenedItemEl = latestOpenedItemElRef.current;

    closeLatestOpenedItem();

    <span class="hljs-keyword">if</span> (currentTarget === latestOpenedItemEl) {
      <span class="hljs-keyword">return</span>;
    }

    currentTarget.setAttribute(<span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);
    latestOpenedItemElRef.current = currentTarget;
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>
      {dummyData.map(({ text, context }, index) =&gt; {
        return (
          <span class="hljs-tag">&lt;<span class="hljs-name">Detail</span>
            <span class="hljs-attr">key</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">detail</span>${<span class="hljs-attr">index</span>}`}
            <span class="hljs-attr">popover</span>=<span class="hljs-string">{context}</span>
            <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClickDetail}</span>
          &gt;</span>
            {text}
          <span class="hljs-tag">&lt;/<span class="hljs-name">Detail</span>&gt;</span>
        );
      })}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</div></code></pre>
</body>
</html>